## 課題1-1 TODOを追加した直後、input要素にフォーカスするようにしてください

https://github.com/kmishima16/praha-todo/commit/426ed6142bf7b359f858fe679f494a8d86a2caa0

以下の観点でコードを更新しました
- input要素にフォーカスできるようにするため、`useRef`の参照をinputのrefに登録した
- `useEffect`を使い、inputのvalueが空であれば、inputのrefにフォーカスするようにした
- useReducerの`ADD_TODO`の中に、`inputRef.current?.focus()`してもよいのか？という疑問があった
  - [エフェクトを使って同期を行う](https://ja.react.dev/learn/synchronizing-with-effects)に、「DOMの更新はエフェクトでラップする」と明記されていたので、useEffectを利用しました

## 課題1-2 useEffectが必要になる機能を考えて、実装してみてください

https://github.com/kmishima16/praha-todo/commit/62906fd8f5c2dfc557fc85fb016bfa2ff90bedf5

「各todoに残り時間があり、1秒ごとに残り時間が更新される」処理を追加しました。

![gif todo](https://gyazo.com/1d3bfe324f21238c0ecfde53a5a193d0.gif)

以下の観点でコードを更新しました
- 初回レンダリング時にuseEffectで`setInterval()`を実行して、1秒ごとのタイマー処理を登録する
- `state.todos[]`のtodoの残り時間を更新する、`TICK`という`payload`をuseReducerに追加した
- タイマー処理で、useReducerの`TICK`を呼び出すようにした

## 課題2 useEffectを無くしてみましょうクイズ

`y = a*x^2 / b` という二次関数のグラフが描画されるページがあり、ユーザがa,bの値をインプット要素から指定するとグラフの傾きが更新されるようになっています。

グラフを描画するコンポーネントはsvg要素で作られていて、x,y座標の点配列を線でつないだものになっています。

グラフの傾きを更新するためにuseEffectを使って、a,bが変化すると座標の点配列が更新されるようになっています。

以下の処理はuseEffectを使う必要があるのでしょうか？

```jsx
  const [a, setA] = useState(1)
  const [b, setB] = useState(1)
  const [graphData, setGraphData] = useState<{ x: number; y: number }[]>([])

  useEffect(() => {
    const newGraphData = []
    for (let x = -10; x <= 10; x++) {
      const y = a * (x ** 2) / b
      newGraphData.push({ x, y })
    }
    setGraphData(newGraphData)
  }, [a, b])

  return(
    <div>
      <input
        type="number"
        value={a}
        onChange={e => setA(Number(e.target.value))}
        />
      <input
        type="number"
        value={b}
        onChange={e => setB(Number(e.target.value))}
        />        
    </div>
    // グラフ描画コンポーネント...
  )
```

![gif](https://gyazo.com/1589fc4e826ae8def69039407557c682.gif)


### 答え

before
```jsx
  const [a, setA] = useState(1)
  const [b, setB] = useState(1)
  const [graphData, setGraphData] = useState<{ x: number; y: number }[]>([])

  useEffect(() => {
    const newGraphData = []
    for (let x = -10; x <= 10; x++) {
      const y = a * (x ** 2) / b
      newGraphData.push({ x, y })
    }
    setGraphData(newGraphData)
  }, [a, b])
```


after
```jsx
  const [a, setA] = useState(1)
  const [b, setB] = useState(1)

  // graphDataは直接計算すればよい
  const graphData = []
  for (let x = -10; x <= 10; x++) {
    const y = a * (x ** 2) / b
    graphData.push({ x, y })
  }
```

useEffectの依存配列にa,bを登録しなくても、自動で再レンダリングされる。

