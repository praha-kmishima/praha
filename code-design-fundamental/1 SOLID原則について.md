[1 SOLID原則について](1%20SOLID原則について.md)

[2 改修をアプリでするか、SQLでするか](2%20改修をアプリでするか、SQLでするか.md) →

---

# 課題1

## 1-1 SOLID原則の各要素について　これらを守る事で、どんなメリットがある？

- SRP - 変更される理由は１つだけ原則
- OCP - 受け取ったデータを内部で変更したりするな原則
- LSP - 継承先クラスの入出力で条件を追加したり減らすな原則
- ISP - インターフェースはできるだけ小さくしろ原則
- DIP - 不安定なものは安定したものに依存させろ原則

これらの頭文字をとってＳＯＬＩＤ原則と呼ぶ。
これらの原則が守られることで、変更に強く、理解しやすいコードベースになる。

特にクリーンアーキテクチャ、オニオンアーキテクチャは、このSOLID原則遵守を意識した構造になっている。

## 1-2 単一責任の原則と、単純にファイルを細かく分けることの違いは？

- ２つの違いは、「内部動作に注目するのか？」にある
	- 単一責任原則は、「あるクラス、関数、モジュールは、変更される理由はたった一つ」にする
	- ファイルを細かく分けることは、「あるクラス、関数、モジュール単位のファイル」に分ける

- なぜ、単一責任原則が内部動作を注目するのか？
	- それは、モジュールはどういった理由で変更されるのか、
	- 変更されることでどの範囲まで影響が起こるのか、
	- これらを実装者は意識しておくべき、という思想
- 単純にファイルを細かく分ける理由とは何か？
	- 特定の処理がどのファイルで起きているかが見分けやすくなる
	- 発生した問題が、どの領域で発生したかを見分けやすくなる
	- 全体の構造をファイル名を追うだけで把握できる
- 発生要因が分かりやすく、全体構造を把握しやすいことは、「システム全体が修正しやすい」とは異なる
	- あるモジュールの影響範囲を正確に把握できるとは限らない
	- また、ファイルを分けたとしても依存関係の複雑さは解消はできない

## 1-3 Open-Closed-Principleの実例

- [cart-bad.ts](https://github.com/praha-kmishima/code-design-fundamental/blob/main/src/1-3%20OCP/cart_bad.ts)
- [cart-good.ts](https://github.com/praha-kmishima/code-design-fundamental/blob/main/src/1-3%20OCP/cart_good.ts)

- このサンプルでは、値オブジェクトを使って、以下の2つに分割しました。
	- バリデーション処理を行うモジュール
	- 「バリデーション」が行えるオブジェクトを受け取って、合計処理を行うモジュール
- この変更によって、バリデーション処理が外部で行われるようになったので、合計処理は修正に対して閉じており、拡張に対して開くようになりました。

- この原則に従うということは、結果的に、単一責任原則にも従う、と近しいのかな？と思いました
	- 複数の処理を持つモジュール　→　修正に対して「開いている」
	- 単一責務のモジュール群　→　各モジュールは修正に対して「閉じている」
		- 変更される理由が１つだけになるので、「外部要因に伴う修正」が閉じる
		- そのため、オープンクローズド原則も単一責任原則も満たすようになる、という感覚です

## 1-4 リスコフの置換原則に違反したらどうなる？

- 子クラスは、親クラスと互換性をもつことを保証しないといけない・・・という原則
- もし、保証されていなかったらどうなるのか？
	- 子クラスだけ、エラーを出力する（かもしれない）
	- バリデーション判定をスキップできる子クラスがある（かもしれない）
		- これが許されると、関連クラスについては利用者側でのチェックが必要になってしまう
- 同じふるまいをしてほしいのに、一部のクラスだけ違うふるまいをしてしまうので、詳細な実装を確認しないといけなくなる
	- 「親クラスのふるまいよりも、入力値が厳しく・出力が緩くなってはいけない」という制約を課すことで、利用者は実装を見なくても関連クラスが利用できるようになる　
		- 利用者だけでなく実装者側も、子クラスの詳細を気にせず親クラスの修正ができるようになる

豆知識
- python linterのmypyに、この原則を静的解析でチェックしてくれる機能がある
- [mypyに怒られて理解を進めるリスコフの置換原則 - nikkie-ftnextの日記](https://nikkie-ftnext.hatenablog.com/entry/mypy-liskov-substitution-principle-first-step)

## 1-5 インターフェースを用いることの設計上のメリットは？

- 一言でいうと、依存関係の把握がしやすくなるから。
- インターフェースを介さない依存関係は、実装詳細内で変数やモジュールを呼び出すことによって発生する
- 依存関係呼び出しにインターフェースを介入させることで、「依存関係の中間地点」みたいなものが浮かび上がってくる。
	- インターフェースが依存先になると、実装者にとっても利用者にとっても嬉しいポイントができる
		- 実装者が持つそのモジュールに対しての責任
			- 「インターフェースの要件を満たした実装になっているか」になる
		- 利用者がそのモジュールを使うときの責任
			- 「インターフェースの要件のもと、適切な後処理を行えているか」になる
		- これは、テストコードなどでモックオブジェクトを作るときも効果がある
			- インターフェースの要件を満たしたモックさえ作ってしまえば、動作をチェックするテストを流すことができる
	- 仮にインターフェースが存在せず、他の処理にどう影響を与えているのかが何もわからない状態だと、「現在稼働しているコード」の振る舞いを変更したい場合に、修正容易性が著しく下がってしまう


## 1-6 どんな時に依存性逆転を用いる必要が生じるのでしょうか

- 1-5 でもあったが、依存関係を把握したいときに使うとよい
- 全ての依存関係に対して、インターフェースを介入させる必要はない
	- 引数が多くなりすぎてしまうと、そのモジュールの意味が伝わりにくくなるし、テストも書きにくくなる
	- 極論をいうと、標準ライブラリも全てインターフェース経由で呼び出すモジュールは使いにくい
- 「近いうちに振る舞いを変える場合がありそうな外部モジュール」を使う場合は依存性逆転を行うべき
	- 外部APIとの通信処理を行う関数とか
	- バリデーション処理を含んだ値オブジェクトとか
	- データベースと通信を行うオブジェクトとか
	- 複雑な業務ロジックに基づいた計算処理を行うオブジェクトとか

- ちなみに、依存性逆転は誤訳で、「依存オブジェクトの注入」が正しい、という意見もあるらしい

## 1-7-1 デメテルの法則とは？


- そのオブジェクトが本来知らないはずの知識を使った処理を作ってはいけない
	- 「直接の隣人にのみ話しかけてもよい」
	- メソッドチェーンを使って、「呼び出し先のモジュールが呼び出した関数の帰り値のオブジェクトが呼び出した関数の帰り値のオブジェクトのプロパティを使う」みたいな処理を作らない
	- `const flag = user.BasicInfo.Configuration.getAddon().IsEnabled`みたいなやつはだめ
		- Google Apps Scriptとかの公開API使うと、こういうコード書きがちな気がする・・・
		- jQueryでDOM操作する時とかも
- 各オブジェクトの知識の境界が管理されることで、モジュール間の密結合が防げるようになる

豆知識
- 1987年に、イースイースタン大学で作成され、Ian Hollandによって提唱された
- 「最小知識の原則」とも呼ばれる
- この法則の目的はオブジェクト間の結合度を低く保ち、システムの保守性を向上させること
- オブジェクト間の依存関係を最小限に抑える実験のデメテルプロジェクトにちなんで名づけられた法則
	- ちなみに、デメテルは、「豊穣の女神デメテル」が元ネタ

R言語はメソッドチェーンが主流
- データ分析用のR言語とかPythonだと、メソッドチェーンが多用される
- あとはC#も
- メソッドチェーンは一律ダメというわけではなくて、振る舞いの異なるレイヤー間を行き来するようなメソッドチェーンは禁止すべき、というのが正しいのかもしれない？

## 1-7-2 getter, setterだけのクラス

保守性が低くなる理由
- このクラスへの依存先が増えてくると、仕様変更による修正が難しくなる
	- 特定のproductIDに対するバリデーションを行いたいとき
		- コンストラクタにバリデーションを追加すると・・・
			- 依存先のモジュールで、本来バリデーションされるはずの値をトリガーに何か処理を走らせているかもしれない
		- 対策として、各依存先のモジュールにバリデーションを追加してもらうようにすると・・・
			- 複数のモジュールで、同じようなバリデーションを書く必要があるかもしれない
- このクラスは、プロパティを公開しているだけで、何の振る舞いも示せていない
	- 現状、このクラスを利用する人は、プロパティにアクセスするか、データをセットすることしかできない
	- 使われる用途としては、
		- 購入処理の際にuserIDとproductIDをセットして、ＤＢにデータを渡す
		- 履歴表示の際にＤＢから取得したuserIDとproductIDをセットして、ＶＩＥＷのクラスにオブジェクトを渡す
		- など
	- ゲッター、セッターが公開されていることで、どんな使い方もできてしまうため、様々なロジックと密結合が起こりうる

