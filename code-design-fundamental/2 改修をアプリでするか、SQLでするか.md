[2 改修をアプリでするか、SQLでするか](2%20改修をアプリでするか、SQLでするか.md)

← [1 SOLID原則について](1%20SOLID原則について.md) | [3 company,personクラスの修正](3%20company,personクラスの修正.md) →

---

## 課題2

- 例題のコードのふるまい：
	- 対象userIdの過去の購入商品を全て取得する
	- 購入した商品の中に、指定したproductIdが含まれている場合はエラーを返す
	- 含まれていない場合は購入手続きに進む
- このコードはまだ全ての要件を満たせていない
	- 全ての購入商品から判定しているので、「過去1年間」になっていない
- 今後、ありえそうな仕様変更
	- 「過去1年間」ではなく「過去3か月間」でチェックしたい
	- 「プレミアム会員」の場合はいくらでも買ってよい

### 案①：期間選択して購入商品を取得するSQLを作る

- SQL文を追加する改修を加える
	- startDate, endDateをSQLのwhere句に渡して、特定期間の購入商品を取得できるようにする
- この改修だと、過去１年間以外でも3か月、6か月など柔軟に対応ができる
- ただし、「プレミアム会員かどうか」などの購入ユーザの判定はできない
	- SQLをさらに追加して、UserテーブルとJOINしたものをもってくるか、
	- Userテーブルの情報を取得するコードをアプリの`purchase()`に追加して、アプリ側でバリデーションするか
- 要件が複雑化しそうなら、アプリケーション側でバリデーションできるようにさせたほうが分かりやすくて良い気がする

### 案②:アプリケーション側でバリデーションする

- アプリ側にバリデーション処理を追加して、購入判定処理を改修する
	- 新しくバリデーションクラスを作る
	- 過去の購入日を見て条件を満たすかどうかを判定する処理を追加する
	- `PurchaseService`のコンストラクタの引数にバリデーションを追加する
	- バリデーションの結果がTrueなら、購入手続きに移る
- アプリで実装するメリット
	- インターフェースを使えるので、オープンクローズド原則にのっとった形でアップデートができる
	- 新しい判定条件を追加したい場合は、インターフェースを満たすバリデーションクラスを追加すればよい
- アプリで実装するデメリット
	- 今回の例だと、全ての商品を取得した上でバリデーションを行うので、SQLで直接絞り込む時と比べるとパフォーマンスが落ちる
	- アプリ側でwhere句の絞り込みを指定できない場合、新しくSQLクエリを作成しなければ、パフォーマンス改善することができない
		- 原則DBのクエリを修正してはいけません！というルールになっていると、
		- JOIN処理に近いことをアプリ側でも実装しないといけない・・・なんてことも起こり得る