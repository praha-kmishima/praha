## 課題 1-1

- 参照整合性が確保できず、削除された author の情報が格納された book レコードが保存されてしまう可能性がある。
- 規模が大きくなりテーブルが増えていった場合に、リレーションが貼られていないとどのテーブルのカラムがどのテーブルに紐づいているかが把握できなくなってしまい、アプリケーション側のコード実装から関連を読み取っていく必要が出てくる。

## 課題 1-2

- 一度制約を定義すると後から変更することができない
- 作り直しが前提の時などは外部キー制約を考慮せず作った方が工数は減る

## 課題 2-1

**参照アクションの機能**

- CASCADE
    - 親レコードが削除または更新した場合に子レコードも変更を加える
- SET NULL
    - 親レコードが削除または更新した場合に子レコードを NULL にする
- RESTRICT
    - 子レコードが存在する場合、親レコードは削除・更新できない
- NO ACTION
    - 子レコードが存在する場合、親レコードは削除・更新できない
- SET DEFAULT
    - 親レコードが削除または更新された場合に、子レコードをデフォルト値に設定する

**参照アクションを選択すべきケース**

- CASCADE
    - 例：ブログ記事と関連コメントの関係で、記事が削除されたらコメントも削除する。
- SET NULL
    - 例：ユーザーとプロフィール画像の関係で、画像が削除されてもユーザー情報は残す。
- RESTRICT/NO ACTION
    - 例：カテゴリーと商品の関係で、商品が存在する限りカテゴリーの削除を禁止する。

[MySQL :: MySQL 8.0 リファレンスマニュアル :: 13.1.20.5 FOREIGN KEY の制約](https://dev.mysql.com/doc/refman/8.0/ja/create-table-foreign-keys.html#foreign-key-referential-actions)

## 課題 2-2

部署の統廃合などで、部署自体が削除されるケースは多い。こういったケースにおいて、 `on delete cascase` が設定されていると、部署に所属している従業員ごと削除されてしまう。

こういった場合は、参照アクションは設定しないほうがよい。

## 課題 2-3

not null 制約がかかったカラムに対して `on delete set null` による null 値の更新アクションが実行されると、データベース側は整合性違反を起こし、エラーを返す。そのため、データ削除処理が失敗してしまう。

こういった場合は、 `on delete restrict` などで担当者を削除できないようにしておく

## 課題 2-4

MySQL と PostgreSQL における `RESTRICT` と `NO ACTION` の違い：

- MySQL：`RESTRICT` と `NO ACTION` は同じ動作をする。両方とも、参照整合性違反が発生する操作を即座に拒否する。
- PostgreSQL：`RESTRICT` は即座に操作を拒否するが、`NO ACTION` はトランザクションの終了時まで制約チェックを遅延させることができる。これにより、一時的な整合性違反を許容しつつ、最終的には整合性を保つことが可能。

Prisma と TypeORM の参照アクション：

- prisma
    - デフォルト値：`Restrict`
        - 理由：データの整合性を保つため。親レコードの削除や更新を防ぎ、意図しないデータ損失を避ける。ただし、`onDelete` や `onUpdate` を明示的に指定することもできる
- typeORM
    - デフォルト値：`NO ACTION`
        - 理由：データの整合性を保つ制約がかかっているが、postgreSQL を使っている場合は Restrict よりも制約が緩い。`onDelete` や `onUpdate` を使用して他の動作を指定することも可能。

## 課題 3-1

1. 外部キー制約として参照されているカラム名を変更したい場合、どういった処理を行えばよいでしょうか？
2. 外部キー制約が利用されているテーブルは、利用されていないテーブルと比べて、挿入時や削除時のパフォーマンスに違いはあるでしょうか？
3. 外部キー制約に違反する場合のエラーメッセージはどういったものでしょうか？MYSQL と PostgreSQL それぞれ教えてください。